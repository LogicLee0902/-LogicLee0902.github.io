# Chapter2 进程与线程

## 2.1 进程与线程

### 2.1.1 进程的概念和特征

#### 进程的概念

&emsp;在多道程序环境下。允许多个程序并发执行。而如果不加任何约束，则整个过程会的很乱，会失去封闭性，还会对资源进行竞争，同步性也无法保证。因此，引入进程（Process），实现操作系统的**并发性和共享性**（操作系统的最基本的特性之二）
&emsp;为了管理好每个进程（包括其数据和程序），为之配置一个专门的数据结构，进程控制块（Process Control Block， PCB）。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。也将程序段、相关数据段、PCB三部分的组合称为**进程实体**，（又称进程映像），其与进程的区别在于，进程是动态的，进程映像是静态的。
&emsp;由于PCB的引入，我们便可以将进程进行抽象化处理。我们创建进程，也就是创建进程实体中的PCB，而撤销进程，实质上就是撤销进程的PCB。因此可以看出，**PCB是进程存在的唯一标志**。

&emsp;从不同的角度，进程可以有不同的定义，如下

1. 进程是程序的一次执行过程
2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
3. 进程是具有独立功能的程序在一个数据集合上运行的过程,是系统进程资源分配和调度的一个独立单位

#### 进程的特征

&emsp;进程是由多道程序的并发执行而引出的,和程序是两个截然不同的概念。。进程的基本特征如下：

1. 动态性。进程是程序的一次执行，有着创建、活动、暂停、终止等过程，具有一定的生命周期性。动态性是进程的**最基本特征**
2. 并发性。指多个进程实体同存于内存中，能在一段时间内同时运行。引入进程的目的是使进程能和其他进程并发执行。并发是进程和操作系统的重要特征。
3. 独立性。指进程实体是一个独立运运行，独立获得资源和独立接受调度的**基本单位**。在由于其和PCB之间的关系，**凡是为建立PCB的程序，都无法作为一个独立的单位参与运行**
4. 异步性。进程相互竞争，进程各按各的、不可预知的速度向前推进。异步性会导致不可预知的结果，因此需要OS配置相应的**进程同步机制**

### 2.1.2 进程的状态与转换

&emsp;通常进程有5种状态

1. 运行态。正在处理机上运行
2. 就绪态。获得了除了处理机外的一切所需资源。一旦得到处理机  便可以立即运行。处于就绪态的进程一般很多，以队列的形式组织。称为就绪队列
3. 阻塞态，或等待态。进程正在等待别的事件而暂停运行。如等待某个资源解除别的进程对它的占用，或等待输入输出的完成。即使处理机空闲，该进程也不能运行。多个阻塞态的进程也会用队列组织起来，称为阻塞队列。
4. 创建态。进程正在被创建，尚未转到就绪态。创建进程的步骤
   * 申请一个空白PCB，并向其写入用于控制和管理进程的信息
   * 为该进程分配运行所需的资源
   * 把该进程转入就绪态并插入就绪队列。但如果进程所需的资源尚不能得到满足(如内存不足)，则创建工作无法完成，此时状态为创建态。
5. 结束态。进程正从系统中消失，可能是进程正常结束或其他原因退出运行。进程需要结束运行时，系统首先将该进程设置为结束态，然后进一步处理释放资源和回收等

前三个态是进程的基本状态。
状态间的转换如下：

![env_shift](https://s2.loli.net/2022/06/11/9ifs4Zg8ozITkDU.png)

注意，运行态转换为就绪态，除了因为时间到变成就绪态后，在可抢占的操作系统，又有更高优先级的进程就绪时，调度程序会将正在执行的进程转换为就绪态
而从运行态转换为就绪态时，进程从**系统调用**的形式请求OS提供服务，这就是由运行用户态程序调用操作系统内核过程的形式。而从运行态变成阻塞态这一行为是**主动的行为**，与需要其他相关进程协助的、**被动**的从阻塞态变成就绪态不同。

### 2.1.3 进程的组织

**进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位**。其核心部分就是PCB

#### PCB

&emsp;在进程创建得到一个PCB，该结构常驻内存，任何时候都可以存取，直到进程结束后删除。操作系统也是依靠PCB了解进程的状态信息，从而对其进行管理。
&emsp;当OS想要调度进程时，要先从PCB获得进程的现行状态和优先级；在地道都到某进程后，根据PCB中保存的处理机的状态信息，设置该进程的**恢复运行**的现场，并根据PCB中程序和数据的内存始址，获取他们。此外，在进程运行时，如果需要实现同步、通信或是访问文件等，也需要访问PCB；当进程由于某种原因而暂停时，也是需要把断点的处理机环境保存在PCB。可见，在进程的整个生命周期，OS都是通过PCB对其控制的。
PCB保存的内容可大致用下表概括。

| 进程描述信息    | 进程控制和管理信息 | 资源分配清单 | 处理机相关信息 |
| --------------- | ------------------ | ------------ | -------------- |
| 进程标识符(PID) | 进程当前状态       | 代码段指针   | 通用寄存器值   |
| 用户标识符(UID) | 进程优先级         | 数据段指针   | 地址寄存器(PC) |
|                 | 代码运行入口地址   | 堆栈指针     | 控制器寄存器   |
|                 | 程序的外存地址     | 文件描述符   | 标志寄存器     |
|                 | 进入内存时间       | 键盘         | 状态字         |
|                 | 处理机占用时间     | 鼠标         | .              |
|                 | 信号量使用         |              |                |

1. 进程描述信息。进程标识符：标志各个进程，每个进程都有一个**唯一的**标识号。用户标识符：进程归属的用户，用户标识符主要为**共享和保护**服务。
2. 进程控制和管理信息。进程当前状态：描述进程的状态信息，作为处理机分配调度的依据。进程优先级：描述进程抢占处理机的优先级，优先级高的进程可优先获得处理机。
3. 资源分配清单，用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入输出设备信息。
4. 处理机相关信息，也称处理机的上下文，主要指处理机中各寄存器的值。当进程被切换时，处理机状态信息都必须保存在相应的PCB中，以便在该进程重新执行时，能从断点继续执行。

对于不同的PCB，要将各个PCB组织起来，有索引和链接两种方式。链接是将同一状态的PCB链接成一个队列，不同状态不同队列，或是将阻塞态的PCB，根据阻塞原因的不同，排成多个阻塞队列。索引是将同一状态的进程组织在一个索引表里，索引表的表项指向对应的PCB，不同状态就对应不同的索引表。

#### 程序段

&emsp;是能被进程调度程序调度到CPU执行的程序代码段。**注意**，程序可被多个进程共享，也就是多个进程可以运行同一个程序。

#### 数据段

&emsp;任何数据，可以是原始的数据，也可以是执行时产生的中间或最终结果。(涉及断点、wait等，需要保存)

### 2.1.4 进程控制

&emsp;其主要功能是对系统中所有线程进行管理。基本的职责为创建新进程、撤销已有进程、实现进程状态转换等功能。在OS中，一般把进程控制用的程序段称为**原语**，其特点是执行不会被打断，不可分割

#### 进程的创建

&emsp;允许一个父进程创建子进程(fork)，子进程可以继承父进程所拥有的资源。子进程撤销时，会将从父进程得到的资源归还给父进程；撤销父进程时，会把它的子进程全部撤销了。

进程的创建，也可以称为创建原语如下：

1. 为新线程分配唯一的PID，并申请空白的PCB(PCB是有限的)，若申请失败就是创建失败。
2. 为进程分配所需的资源，如内存、文件等。这些资源从OS或者是父进程中获得，如果资源不足，则处于**创建态**，等待内存资源。（并不会创建失败）
3. 初始化PCB，主要包括初始化标志信息，初始化处理机信息和初始化处理机控制信息，设置线程的优先级等。
4. 若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行

#### 进程的终止

导致进程终止的时间主要有：

* 正常结束，任务完成
* 异常结束，进程运行时，发生了异常事件(如存储区越界，非法指令，算数错误等)
* 外界干预，指进程应外界的请求而终止运行，如OS干预、父进程请去和父进程终止

终止原语如下

1. 根据被终止进程的标识符，检索出对应的PCB，读出该进程的状态。
2. 若处于执行状态，立马终止进程，将处理机资源分配给其他进程(先管理处理机资源)
3. 若该进程还有子孙进程，也依个将其终止
4. 将进程所拥有的全部资源，或归还OS，或归还给父进程
5. 将PCB从所在队列中删除

#### 进程的阻塞和唤醒

&emsp;通过阻塞原语，将自己运行态变为阻塞态。阻塞是一种主动行为，因此只有处于运行态(获得CPU)的进程可以转换为阻塞态
阻塞原语如下

1. 找到将要被阻塞的进程的标识号对应的PCB
2. 判断是否为运行态。若是运行态，则保护现场，转换为阻塞态，停止运行
3. 把PCB插入相应的等待队列(所谓相应就是需要等待的事件一致)，将处理机资源调度给其他就绪态进程

&emsp;当进程期待的事件出现后，可以用唤醒原语将其唤醒。唤醒的过程如下：

1. 在该事件的等待队列中找到相应的PCB
2. 从等待队列中移出，设置为就绪态
3. 插入就绪队列，等待调度程序调度

不难看出，阻塞原语和唤醒原语是一对作用完全相反的原语，必须成对使用。如果使用了阻塞原语，则必须在相关的进程中使用唤醒原语，否则，阻塞态进程将**永远处于阻塞态**

#### 进程的通信

&emsp;所谓通信，就是进程之间的信息交换。PV操作是低级通信方式(后面会具体说)，高级通信方式是zh指以较高的效率传输大量数据的通信方式。高级通信方式主要有以下三类。

##### 共享储存

&emsp;用一块可直接访问的共享空间，通过对这篇共享空间进行读写操作实现信息叫交换。对共享空间进行读写操作时，需要用同步互斥工具(如PV操作，信号量机制等)。共享储存可分为两种。

* 基于数据结构的共享，较为低级
* 基于存储区的共享，较为高级。

操作系统一般只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读写指令完成。
一般情况下，进程空间是互相独立的，不能访问其他进程的空间，所以如果需要共享空间，必须通过特殊的系统的调用实现，而**进程内的线程是自然共享空间的**

###### 消息传递

&emsp;数据以格式化的消息为单位进行交换。其也是当前**应用最广泛的进程间通信机制**，若通信的进程之间不存在可直接访问的共享空间，则必须利用OS提供的消息传递方式实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进程数据交换，这样简化了通信程序涉及，使通信过程对用户透明。微内核与服务器之间的通信就是用这个机制
具体来说，也有直接通信和间接通信两种。直接方式，发送进程直接将消息挂在接受京城的消息换队列上，接受进程从中取得消息；间接方式通过一个中间实体，被称为信箱，间接法常用于计算机网络

##### 管道通信

&emsp;消息传递的特殊方式，所谓管道(pipe)，也就是连接一个读进程和一个写进程以实现他们之间的通信的共享文件。向文件提供输入的写进程，以字符流形式将大量写数据送入写管道；而读管道输出的读进程则从管道中读数据。管道的实现，要求以下的协调能力:互斥、同步和确定对方存在
&emsp;Linux中使用频繁的通信机制，从本质上来说，管道也是一种文件，但其克服了使用文件通信的两个问题，使其与一般文件略有不同

* 限制管道的大小。管道是有固定大小的缓冲区，Linux中管道为4KB，这样的限制使得其不像文件那样不加检验的增大使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供wite()调用写。
* 读进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题
* 
* 。