# Chapter2 进程与线程

## 2.1 进程与线程

### 2.1.1 进程的概念和特征

#### 进程的概念

&emsp;在多道程序环境下。允许多个程序并发执行。而如果不加任何约束，则整个过程会的很乱，会失去封闭性，还会对资源进行竞争，同步性也无法保证。因此，引入进程（Process），实现操作系统的**并发性和共享性**（操作系统的最基本的特性之二）
&emsp;为了管理好每个进程（包括其数据和程序），为之配置一个专门的数据结构，进程控制块（Process Control Block， PCB）。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。也将程序段、相关数据段、PCB三部分的组合称为**进程实体**，（又称进程映像），其与进程的区别在于，进程是动态的，进程映像是静态的。
&emsp;由于PCB的引入，我们便可以将进程进行抽象化处理。我们创建进程，也就是创建进程实体中的PCB，而撤销进程，实质上就是撤销进程的PCB。因此可以看出，**PCB是进程存在的唯一标志**。

&emsp;从不同的角度，进程可以有不同的定义，如下

1. 进程是程序的一次执行过程
2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
3. 进程是具有独立功能的程序在一个数据集合上运行的过程,是系统进程资源分配和调度的一个独立单位

#### 进程的特征

&emsp;进程是由多道程序的并发执行而引出的,和程序是两个截然不同的概念。。进程的基本特征如下：

1. 动态性。进程是程序的一次执行，有着创建、活动、暂停、终止等过程，具有一定的生命周期性。动态性是进程的**最基本特征**
2. 并发性。指多个进程实体同存于内存中，能在一段时间内同时运行。引入进程的目的是使进程能和其他进程并发执行。并发是进程和操作系统的重要特征。
3. 独立性。指进程实体是一个独立运运行，独立获得资源和独立接受调度的**基本单位**。在由于其和PCB之间的关系，**凡是为建立PCB的程序，都无法作为一个独立的单位参与运行**
4. 异步性。进程相互竞争，进程各按各的、不可预知的速度向前推进。异步性会导致不可预知的结果，因此需要OS配置相应的**进程同步机制**

### 2.1.2 进程的状态与转换

&emsp;通常进程有5种状态

1. 运行态。正在处理机上运行
2. 就绪态。获得了除了处理机外的一切所需资源。一旦得到处理机  便可以立即运行。处于就绪态的进程一般很多，以队列的形式组织。称为就绪队列
3. 阻塞态，或等待态。进程正在等待别的事件而暂停运行。如等待某个资源解除别的进程对它的占用，或等待输入输出的完成。即使处理机空闲，该进程也不能运行。多个阻塞态的进程也会用队列组织起来，称为阻塞队列。
4. 创建态。进程正在被创建，尚未转到就绪态。创建进程的步骤
   * 申请一个空白PCB，并向其写入用于控制和管理进程的信息
   * 为该进程分配运行所需的资源
   * 把该进程转入就绪态并插入就绪队列。但如果进程所需的资源尚不能得到满足(如内存不足)，则创建工作无法完成，此时状态为创建态。
5. 结束态。进程正从系统中消失，可能是进程正常结束或其他原因退出运行。进程需要结束运行时，系统首先将该进程设置为结束态，然后进一步处理释放资源和回收等

前三个态是进程的基本状态。
状态间的转换如下：

![env_shift](https://s2.loli.net/2022/06/11/9ifs4Zg8ozITkDU.png)

注意，运行态转换为就绪态，除了因为时间到变成就绪态后，在可抢占的操作系统，又有更高优先级的进程就绪时，调度程序会将正在执行的进程转换为就绪态
而从运行态转换为就绪态时，进程从**系统调用**的形式请求OS提供服务，这就是由运行用户态程序调用操作系统内核过程的形式。而从运行态变成阻塞态这一行为是**主动的行为**，与需要其他相关进程协助的、**被动**的从阻塞态变成就绪态不同。

### 2.1.3 进程的组织

**进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位**。其核心部分就是PCB

#### PCB

&emsp;在进程创建得到一个PCB，该结构常驻内存，任何时候都可以存取，直到进程结束后删除。操作系统也是依靠PCB了解进程的状态信息，从而对其进行管理。
&emsp;当OS想要调度进程时，要先从PCB获得进程的现行状态和优先级；在地道都到某进程后，根据PCB中保存的处理机的状态信息，设置该进程的**恢复运行**的现场，并根据PCB中程序和数据的内存始址，获取他们。此外，在进程运行时，如果需要实现同步、通信或是访问文件等，也需要访问PCB；当进程由于某种原因而暂停时，也是需要把断点的处理机环境保存在PCB。可见，在进程的整个生命周期，OS都是通过PCB对其控制的。
PCB保存的内容可大致用下表概括。

| 进程描述信息    | 进程控制和管理信息 | 资源分配清单 | 处理机相关信息 |
| --------------- | ------------------ | ------------ | -------------- |
| 进程标识符(PID) | 进程当前状态       | 代码段指针   | 通用寄存器值   |
| 用户标识符(UID) | 进程优先级         | 数据段指针   | 地址寄存器(PC) |
|                 | 代码运行入口地址   | 堆栈指针     | 控制器寄存器   |
|                 | 程序的外存地址     | 文件描述符   | 标志寄存器     |
|                 | 进入内存时间       | 键盘         | 状态字         |
|                 | 处理机占用时间     | 鼠标         | .              |
|                 | 信号量使用         |              |                |

1. 进程描述信息。进程标识符：标志各个进程，每个进程都有一个**唯一的**标识号。用户标识符：进程归属的用户，用户标识符主要为**共享和保护**服务。
2. 进程控制和管理信息。进程当前状态：描述进程的状态信息，作为处理机分配调度的依据。进程优先级：描述进程抢占处理机的优先级，优先级高的进程可优先获得处理机。
3. 资源分配清单，用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入输出设备信息。
4. 处理机相关信息，也称处理机的上下文，主要指处理机中各寄存器的值。当进程被切换时，处理机状态信息都必须保存在相应的PCB中，以便在该进程重新执行时，能从断点继续执行。

对于不同的PCB，要将各个PCB组织起来，有索引和链接两种方式。链接是将同一状态的PCB链接成一个队列，不同状态不同队列，或是将阻塞态的PCB，根据阻塞原因的不同，排成多个阻塞队列。索引是将同一状态的进程组织在一个索引表里，索引表的表项指向对应的PCB，不同状态就对应不同的索引表。

#### 程序段

&emsp;是能被进程调度程序调度到CPU执行的程序代码段。**注意**，程序可被多个进程共享，也就是多个进程可以运行同一个程序。

#### 数据段

&emsp;任何数据，可以是原始的数据，也可以是执行时产生的中间或最终结果。(涉及断点、wait等，需要保存)

### 2.1.4 进程控制

&emsp;其主要功能是对系统中所有线程进行管理。基本的职责为创建新进程、撤销已有进程、实现进程状态转换等功能。在OS中，一般把进程控制用的程序段称为**原语**，其特点是执行不会被打断，不可分割

#### 进程的创建

&emsp;允许一个父进程创建子进程(fork)，子进程可以继承父进程所拥有的资源。子进程撤销时，会将从父进程得到的资源归还给父进程；撤销父进程时，会把它的子进程全部撤销了。

进程的创建，也可以称为创建原语如下：

1. 为新线程分配唯一的PID，并申请空白的PCB(PCB是有限的)，若申请失败就是创建失败。
2. 为进程分配所需的资源，如内存、文件等。这些资源从OS或者是父进程中获得，如果资源不足，则处于**创建态**，等待内存资源。（并不会创建失败）
3. 初始化PCB，主要包括初始化标志信息，初始化处理机信息和初始化处理机控制信息，设置线程的优先级等。
4. 若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行

#### 进程的终止

导致进程终止的时间主要有：

* 正常结束，任务完成
* 异常结束，进程运行时，发生了异常事件(如存储区越界，非法指令，算数错误等)
* 外界干预，指进程应外界的请求而终止运行，如OS干预、父进程请去和父进程终止

终止原语如下

1. 根据被终止进程的标识符，检索出对应的PCB，读出该进程的状态。
2. 若处于执行状态，立马终止进程，将处理机资源分配给其他进程(先管理处理机资源)
3. 若该进程还有子孙进程，也依个将其终止
4. 将进程所拥有的全部资源，或归还OS，或归还给父进程
5. 将PCB从所在队列中删除

#### 进程的阻塞和唤醒

&emsp;通过阻塞原语，将自己运行态变为阻塞态。阻塞是一种主动行为，因此只有处于运行态(获得CPU)的进程可以转换为阻塞态
阻塞原语如下

1. 找到将要被阻塞的进程的标识号对应的PCB
2. 判断是否为运行态。若是运行态，则保护现场，转换为阻塞态，停止运行
3. 把PCB插入相应的等待队列(所谓相应就是需要等待的事件一致)，将处理机资源调度给其他就绪态进程

&emsp;当进程期待的事件出现后，可以用唤醒原语将其唤醒。唤醒的过程如下：

1. 在该事件的等待队列中找到相应的PCB
2. 从等待队列中移出，设置为就绪态
3. 插入就绪队列，等待调度程序调度

不难看出，阻塞原语和唤醒原语是一对作用完全相反的原语，必须成对使用。如果使用了阻塞原语，则必须在相关的进程中使用唤醒原语，否则，阻塞态进程将**永远处于阻塞态**

### 2.1.5 进程的通信

&emsp;所谓通信，就是进程之间的信息交换。PV操作是低级通信方式(后面会具体说)，高级通信方式是zh指以较高的效率传输大量数据的通信方式。高级通信方式主要有以下三类。

#### 共享储存

&emsp;用一块可直接访问的共享空间，通过对这篇共享空间进行读写操作实现信息叫交换。对共享空间进行读写操作时，需要用同步互斥工具(如PV操作，信号量机制等)。共享储存可分为两种。

* 基于数据结构的共享，较为低级
* 基于存储区的共享，较为高级。

操作系统一般只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读写指令完成。
一般情况下，进程空间是互相独立的，不能访问其他进程的空间，所以如果需要共享空间，必须通过特殊的系统的调用实现，而**进程内的线程是自然共享空间的**

#### 消息传递

&emsp;数据以格式化的消息为单位进行交换。其也是当前**应用最广泛的进程间通信机制**，若通信的进程之间不存在可直接访问的共享空间，则必须利用OS提供的消息传递方式实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进程数据交换，这样简化了通信程序涉及，使通信过程对用户透明。微内核与服务器之间的通信就是用这个机制
具体来说，也有直接通信和间接通信两种。直接方式，发送进程直接将消息挂在接受京城的消息换队列上，接受进程从中取得消息；间接方式通过一个中间实体，被称为信箱，间接法常用于计算机网络

#### 管道通信

&emsp;消息传递的特殊方式，所谓管道(pipe)，也就是连接一个读进程和一个写进程以实现他们之间的通信的共享文件。向文件提供输入的写进程，以字符流形式将大量写数据送入写管道；而读管道输出的读进程则从管道中读数据。管道的实现，要求以下的协调能力:互斥、同步和确定对方存在
&emsp;Linux中使用频繁的通信机制，从本质上来说，管道也是一种文件，但其克服了使用文件通信的两个问题，使其与一般文件略有不同

* 限制管道的大小。管道是有固定大小的缓冲区，Linux中管道为4KB，这样的限制使得其不像文件那样不加检验的增大使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供wite()调用写。
* 读进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题

&emsp;管道使一次性操作，数据一旦被读取，就释放空间以便写入更多数据。管道只能单向传输(叫做半双工通信)，要实现父子进程的通信，就需要定义两个管道。
&emsp;管道也可以看作共享存储的优化。共享存储要读的时候，则有可能因为已经被占用而被阻塞的可能，而管道的缓存区只允许一边写，另一边读。而写的时候会将缓存区写满。所以只要缓存区有数据，读进程就可以读出，此时也不会有写进程打扰。

### 2.1.6 线程和多线程模型

#### 线程的概念

&emsp;引入进程是为了更好地使多道程序并发执行，提高资源利用率和系统吞吐量。引入线程使为例减小程序在并发执行的时空开销，提高并发性能。
&emsp;线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由**线程ID、程序计数器、寄存器集合和堆栈组成**。
&emsp;线程是进程中的一个实体，是**被系统独立调度和分派的基本单位**，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程**共享进程所拥有的全部资源**。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。线程也有就绪、阻塞和运行三种基本状态。
&emsp;因此线程时作为除CPU外的系统资源(如内存，I/O等)的分配单元，而线程则作为处理机的分配单元。同个进程的不同线程切换的时空开销很小

#### 线程和进程比较

* 调度。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程，每次调度都要进行上下文切换，开销较大。**在引入线程的操作系统中，线程是独立调度的基本单位**，而线程切换的代价远低于进程。在同一进程中，线程的切换不会引起进程切换。但从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
* 并发性。在引入线程的操作系统中，不仅进程之间可以并发执行，而且一个进程中的多个线程之间亦可并发执行，甚至不同进程中的线程也能并发执行，从而使操作系统具有更好的并发性，提高了系统资源的利用率和系统的吞吐量。
* 拥有资源 。进程是系统中拥有资源的基本单位，而线程不拥有系统资源(仅有一点必不可少、能保证独立运行的资源)，但线程可以访问其隶属进程的系统资源，**这主要表现在属于同一进程的所有线程都具有相同的地址空间**。若线程也是拥有资源的单位，则切换线程就需要较大的时空开销，线程这个概念的提出就没有意义。
* 独立性。每个进程都有独立的地址空间和资源，除了共享全局变量，不允许其他进程访问。**某进程中的线程对其他进程不可见**。同一进程中的不同线程是为了提高并发性及进行相互之间的合作而创建的，**它们共享进程的地址空间和资源**。
* 系统开销。创建、切换进程的开销远大于线程。由于同一进程的线程共享地址空间，因此其同步和通信也很容易，无须操作系统干预。
* 支持多处理机系统。单线程进程，进程只能分配在一个处理机上，多线程进程则可将多个线程分配到多个处理机上。

#### 线程的属性

引入线程后，所谓进程在处于执行状态，实际上就是该进程的某线程正在执行。
线程的属性如下：

* 线程不拥有系统资源，但其也有唯一的标识符和一个线程控制块，其中记录了线程执行的寄存器和栈等现场状态
* 不同线程可以执行相同的程序，即一个程序被不同用户调用是处理为不同的线程
* 进程中的线程共享资源
* 线程是处理机的独立调度单位

#### 线程的生命周期

* 线程的状态与转换与进程无异。
* 类似于线PCB，进程也有一个TCB(Thread Control Block)，用于记录控制和管理线程的信息。线程控制块通常包括：①线程标识符；②一组寄存器，包括程序计数器、状态寄存器和通用寄存器；③线程运行状态，用于描述线程正处于何种状态：④优先级：⑤线程专有存储区，线程切换时用于保存现场等：⑥堆栈指针，用于过程调用时保存局部变量及返回地址等。
* 因为同个进程间的线程间完全共享，因此一个线程可以读写甚至清楚另一个线程的堆栈
* 线程的创建与终止与进程很多程度上无异。区别在于，存在一种系统线程，一旦被建立，便一直允许不会终止。当用户程序启动时，通常仅有一个称为“初始化线程”的线程正在执行，其主要功能是用于创建新线程。线程终止后也有不同，线程被终止后不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时资源才能被其他线程利用。**并且**，被终止但未释放资源的线程仍可被其他线程调用，以使被终止线程**重新恢复运行**。

#### 线程的实现方法

线程的实现可以分为两类：用户级线程(User-Level Thread,ULT)和内核级线程(Kernel-LevelThread,KLT)。内核级线程又称内核支持的线程。

##### 用户级线程(ULT)

&emsp;在用户级线程中，有关线程管理(创建、撤销和切换等)的所有工作都由应用程序在用户空间中完成，**内核意识不到线程的存在**。通常，应用程序从单线程开始，在该线程中开始运行，在其运行的任何时刻，都可以创建一个在相同进程中运行的新线程。
&emsp;对于设置了用户级线程的系统，**其调度仍是以进程为单位进行的，各个进程轮流执行一个时间片**。感觉像是一个进程拥有一个TCB，因此一个时间片一个进程只能有一个线程在运行。假设进程A包含1个用户级线程，进程B包含100个用户级线程，这样，进程A中线程的运行时间将是进程B中各线程运行时间的100倍，因此对线程来说实质上是不公平的。这种实现方式的优点如下：

* 线程切换不需要转换到内核空间，节省了模式切换的开销。
* 调度算法可以是进程专用的，不同的进程可根据自身的需要，对自己的线程选择不同的调度算法。
* 用户级线程的实现与操作系统平台无关，对线程管理的代码是属于用户程序的一部分。
  
这种实现方式的缺点如下：

* 系统调用的阻塞问题，当线程执行一个系统调用时，不仅该线程被阻塞，而且进程内的所有线程都被阻塞。
* 不能发挥多处理机的优势，**内核每次分配给一个进程的仅有一个CPU,因此进程中仅有一个线程能执行。**

#### 内核级线程(KLT)

&emsp;在操作系统中，无论是系统进程还是用户进程，都是在操作系统内核的支持下运行的，与内核紧密相关。内核级线程同样也是在内核的支持下运行的，**线程管理的所有工作也是在内核空间内实现的。内核空间也为每个内核级线程设置一个线程控制块，内核根据该控制块感知某线程的存在，并对其加以控制.**
&emsp;这种实现方式的优点如下：

* 能发挥多处理机的优势，内核能**同时调度同一进程中的多个线程**并行执行。
* 如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用处理机，也可运行其他进程中的线程。
* 内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。
* 内核本身也可采用多线程技术，可以提高系统的执行速度和效率。
  
这种实现方式的缺点如下：

* 同一进程中的线程切换，需要从用户态转到核心态进行，系统开销较大。这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的。

#### 组合方式

&emsp;有些系统使用组合方式的多线程实现。在组合实现方式中，内核支持多个内核级线程的建立、调度和管理，同时允许用户程序建立、调度和管理用户级线程。**一些内核级线程对应多个用户级线程**，这是用户级线程通过时分多路复用内核级线程实现的。同一进程中的多个线程可以同时在多处理机上并行执行，且在阻塞一个线程时不需要将整个进程阻塞，所以组合方式能结合KLT和ULT的优点，并且克服各自的不足。
各个的示意图如下图所示：

&emsp;在线程实现方式的介绍中，提到了通过线程库来创建和管理线程。线程库(thread library)是为程序员提供创建和管理线程的API。实现线程库主要的方法有如下两种：
①在用户空间中提供一个没有内核支持的库。**这种库的所有代码和数据结构都位于用户空间中。**这意味着，调用库内的一个函数只导致用户空间中的一个本地函数的调用
②实现由操作系统直接支持的内核级的一个库。对于这种情况，**库内的代码和数据结构位于内核空间**。调用库中的一个API函数通常会导致对内核的系统调用。

几种线程的实现方式如下所示

![image.png](https://pic.rmb.bdstatic.com/bjh/215c057ef868b7ddf16226bf564c3c47.png)

&emsp;目前使用的三种主要线程库是：POSIX Pthreads、Windows API、Java.Pthreads作为POSIX标准的扩展，可以提供用户级或内核级的库。Windows线程库是用于Windows操作系统的内核级线程库。Java线程API允许线程在Java程序中直接创建和管理。然而，由于JVM实例通常运行在宿主操作系统之上，Java线程API通常**采用宿主系统的线程库**来实现，因此在Windows系统中Java线程通常采用Windows API来实现，在类UNIX系统中采用Pthreads来实现。

#### 多线程模型

由于**用户级线程和内核级线程连接方式不同**，会形成以下不同的多线程模型

* 多对一模型
  将多个用户级线程映射到一个内核级线程。这些用户进程一般属于一个进程，线程的调度在用户空间完成。仅当用户线程需要访问内核时，才将其映射到一个内核级线程上，但是每次只允许一个线程进行映射。
  * 优点：线程管理是在用户空间进行的，因而效率比较高。
  * 缺点：如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞；在任何时刻，只
* 一对一模型
  将每个用户级线程映射到一个内核级线程
  * 优点：当一个线程被阻塞后，允许调度另一个线程运行，所以并发能力较强。
  * 缺点：每创建一个用户线程，相应地就需要创建一个内核线程，开销较大
* 多对多模型
  将n个用户线程映射到m个内核级线程上
  * 特点：既克服了多对一模型并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程而开销太大的缺点。此外，还拥有上述两种模型各自的优点。


### PS

* 优先级可能是动态的，有可能随着运行而调整
* 不能保证任何时刻都有进程处于运行态(死锁)
* 程序封闭性是指进程执行的结果只取决于进程本身，不受外界影响。也就是说，进程在执行过程中不管是不停顿地执行，还是走走停停，进程的执行速度都不会改变它的执行结果。失去封闭性后，不同速度下的执行结果不同。
* 引入线程后，进程是资源分配的单位，内核级线程是处理器调度和分派的基本单位，线程本身不具有资源
* C语言编写的程序在使用内存时一般分为三个段，它们一般是正文段（即代码和赋值数据段）、数据堆段和数据栈段。二进制代码和常量存放在正文段，动态分配的存储区在数据堆段，临时使用的变量在数据栈段。由此，我们可以确定全局赋值变量在正文段赋值数据段，未赋值的局部变量和实参放在栈段，动态内存分配放在堆段，常量在正文段。
* 注意并发和并行
* 降低优先级的合理时机是进程时间片用完的时候，可以降低让其他的先处理
* 进程从磁盘读数据时会进入阻塞态(算作一种等待输入输出完成)
* 管道仍有可能阻塞，管道为空时读进程阻塞，管道满的时候写进程阻塞