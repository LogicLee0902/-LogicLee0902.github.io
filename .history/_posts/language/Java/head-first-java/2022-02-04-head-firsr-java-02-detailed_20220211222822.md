---
layout:     post
title:      "「Head First Java」 02 Variable"
subtitle:   Java变量与参数
date:       2022-02-04
author:     Leo

header-img: "img/post-java2.png"
catalog: true
tags: ["Java@Languages@Tags", "Head First Java@Books@Series"]
lang: zh
header-style: text
katex: true
---

> 新年好呀，虎年第一更



Java中变量可以氛围primitive主数据类型和对象引用。Primitive主数据为基本的、通用的一些数据类型，如整型，bool型，浮点型等，而对象应用就是实例化的对象。

# 声明变量

## 单变量

primitive类型基本与C/C++大差不差，其所适用的规则是一样的。有一个float的区别在于，若希望小数以float形式处理，则需要在小数点后面加一个f，如`42.5f`

**注意**变量名不能用数字开头。

对象引用并不是保存对象的容器，而是类似指向对象的指针，其也本质上也并不是对象变量，而是引用了对象，并保存对象存取方法的变量。

引用依靠`new 构造函数`创建，且不能向C一样进行运算

引用变量如果没有引用到任何对象则它的值是null

## 数组变量

声明方式与C/C++不同，与C#类似

````java
int[] nums;
nums = new int[7];
// 长度为7的整数数组的构建
//可以简写为
int[] nums = new int[7];

Dog[] pets;
pets = new Dog[7];
//此时还缺少一个实际的dog的对象
pets[0] = new Dog();
//line7,8 可以简写为
Dog[] myDogs = new Dog[3];
````

# 方法操作实例变量

本质也就是函数调用，结果会因为属性的区别而针对每一个实例化展现出个性

## 参数传值

调用方传入实参，方法运用的是形参

Java为**值传递**，即**拷贝传递**，当一个变量作为参数传递时，方法的形参变量会将传递值拷贝过来，原变量不会收到方法变量的影响

若传递的参数时对象，实际上传入的是**远程控制的拷贝**

## 返回值

返回值的也与C/C++一致

一般只能返回一个，需要返回多个类型相同的参数时，需要打包成数组来返回，混有不同类型的用ArrayList（后面会说明）

# 封装

先了解“暴露”

> 暴露：可以简单的认为通过圆点运算符方位的实例变量就可以说这个变量暴露了，之所以称为暴漏因为如果可以通过`.`访问的话，就可以通过外部远程修改了

因此我们需要设定一种方法使得其他程序必须通过此方法（一般命名为Setter）来设定，而不是直接的存取

## 数据隐藏

具体为使用公有和私有的存取修饰符（access modifier）

即公有：public，私有private

**封装的基本原则**：

* 将实例变量标记为私有（private）
* 将公有的`getter` and `setter`来控制存取动作（public）

# 强制类型转换

大部分是一样的，有一个`Integer.parseInt()`

参数：

* `string s`: 字符串（必选）
* `int radix` 基数，默认是10

# 一些小补充

## 实例变量的默认初始化值



| 变量类型  | 初始值 |
| :-------: | :----: |
|  integer  |   0    |
|   float   |  0.0   |
|  boolean  | false  |
| reference |  null  |

## 实例变量于局部变量之间的差别

* **实例变量**在**类**中而非方法中，局部变量定义在方法中
* 局部变量在使用前必须初始化，实例的默认初始化值在先前说了
* 判断引用是否都指向一个对象也是用`==`

