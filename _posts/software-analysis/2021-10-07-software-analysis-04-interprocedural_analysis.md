---
layout: "post"
title: "「Software Analysis」 04 Interprocedual Analysis（Unfinished）"
subtitle: "过程间分析"
author: "roife"
date: 2021-10-10

tags: ["静态分析@Tags@Tags", "PKU - 软件分析@Courses@Series", "SSA@Tags@Tags"]
lang: zh
catalog: true
header-image: ""
header-style: text
katex: true
---

过程间分析指考虑多个函数/过程之间的调用，或者 C/C++ 中的链接时分析。

# 基本思路

1. 对不同过程采用不同抽象域
2. 在调用和返回的时候添加结点来转换信息

例如过程 `A()` 调用过程 `B()`，则会把 `A()` 调用时的信息传入 `B()`，并把 `B()` 的信息传回 `A()`。注意，`B()` 仍然只会被分析一次，即如果由多个地方都调用了 `B()`，那么，会将所有信息全部送入 `B()` 一起分析。这样的好处是能处理递归问题。

## 问题

### 全局变量

全局变量需要添加到对其进行读写的子过程，以及调用这些子过程的过程中（否则离开这个子过程后，全局变量的信息就丢了，而后面可能再次用到这些信息）。

此时会带来很大的开销。

### 精度损失

多个程序调用一个子程序时，输入的信息会被汇总一起分析，此时分析结果会产生精度问题。

例如对于一个常量分析程序（判断在某个程序点某个变量的值是否是常量）：

```c
int id(int a) { return a; }

int main() {
    int x = id(100);
    int y = id(200);
}
```

- 过程内分析不精确的条件：两条互斥的路径都被执行
- 过程间分析不精确的条件：一个过程被调用两次（更加常见）

# Context-sensitivity

上面讲的都是上下文非敏感分析（Context-insensitive analysis），在过程调用的时候忽略调用的上下文。而 Context-sensitivity 可以缓解精度问题。

## 基于克隆的上下文敏感分析

Clone-based Context-Sensitive Analysis。

即调用函数时给每个函数创建一个单独的上下文环境，而不是和前面一样把所有信息汇总到子过程的开头一起分析。

例如 `A()` 调用 `B()`，`C()` 调用 `B()`，则将 `B()` 分别复制两份变成 `B1()` 和 `B2()` 到 `A()` 与 `C()` 中。

### 问题

1. 指数爆炸：在深层的调用栈中重复调用一些函数，会进行大量的复制（问题存在但是不致命）
2. 无法处理递归（导致分析无法进行）

### 解决方案

1. 只复制没有递归调用的函数
2. 只克隆 $k$ 层，即前面 $k$ 层使用上下文敏感分析，后面的都在最后一层上使用上下文非敏感分析
