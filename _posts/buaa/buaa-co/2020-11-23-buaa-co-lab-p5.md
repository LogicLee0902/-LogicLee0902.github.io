---
layout: "post"
title: "「BUAA-CO Lab」 P5 流水线 CPU-lite"
subtitle: "简单流水线 CPU"
author: "roife"
date: 2020-11-23

tags: ["C「BUAA - Computer Organization」", "BUAA", "计算机组成", "L「Verilog-HDL」"]
status: Completed

language: zh-CN
catalog: true
header-image: ""
header-style: text
mathjax: true
---

# 课下总结

P5 做得真是艰难，一方面是流水线这个东西本身比较复杂，包括转发/暂停等一系列机制；另一方面是数据通路由于流水线寄存器的加入，代码量大大上升，个人经验大概比 P4 增加了 1/2 到 1 倍左右。而且 P5 时流水起迭代开发的起点，所以一个好的架构非常重要，所以做的时候会非常想要不停地重构，这又浪费了很多时间。所以建议在做之前先做好设计工作，然后做的过程中不要临时起意去修改。

总的来说流水线的难点在于三方面：
1. 数据通路和控制器架构
2. 转发
3. 暂停

下面我会分别介绍这三方面的内容（主要是教程内容，我会做一些个人理解和细节补充）。

注意：做 P5 前请确保自己熟悉 Verilog 和 P4，并且看完了教程内容和高老板的课件。

# 流水线要点

开发时你需要注意以下几个方面：
1. 命名风格：建议使用 `流水级_名称`，如 `D_instr`
2. 代码排布：建议同一级放在一起，同样的功能放在一起，独立的部分可以适当抽出独立成模块，即遵循“低耦合，高内聚”的原则
3. 多使用宏和常量来简化代码，如推荐使用 `ALU_add` 代替 `3'b001`

## 数据通路及控制架构

### 架构方案选择

数据通路架构即 FDEMW 五个部分的数据通路，以及数据通路中的流水线寄存器。

P5 是 CPU 迭代开发的起点，因此一个好的架构是很好的起点。总的来说架构包括这几部分：

1. 译码方式：分为集中式译码和分布式译码。

    集中式译码即在 `F` 或 `D` 级进行译码，然后将控制信号流水传递，即 P3/P4 采用的译码方式；分布式译码则只流水传递指令，控制信号在每一级单独译码。

    集中式译码的好处在于速度更快，关键路径更短；分布式译码关键路径更长，速度较慢（差不了很多）但是译码信息模块化，不需要流水传递控制信号，更适合应试和学习。

    这里我们采用分布式译码。

2. 译码方式：可以用 `always @(*) + case` 或者 `assign` 进行译码。这里使用后者（因为后者代码更短）。

3. 控制器设计：为每一级单独写一个 CU, 或者写一个大的 CU 每一级实例化一次，取不同的信号使用。

    前者可以节省晶体管，但是实际操作会遇到很多问题：比如指令一多（P6）那样译码信息写起来很麻烦。如果你像我一样，写了一个 `interpreter.v` 来复用解码代码，那样会发现还不如直接单写一个 CU，而且一些信号会重复使用，如寄存器写使能信号在阻塞模块中会重复使用。出于面向对象的工程思想，我们倾向于把信号集中在一起。

    后者写起来简单，但是要使用更多的晶体管。

    这里使用后者。（我们要对编译器抱有信心，相信他会帮我们优化代码的(｡･ω･｡)）

总而言之，我们采用的是更工程化，更符合“高耦合低内聚”原则的方案，效率和成本不是我们考虑的首要因素。

### 数据通路架构

数据通路部分的元件基本上和 P4 一样，我们将它们分在不同的层级。
1. F 级：PC，IM
2. D 级：GRF，EXT，CMP，NPC
3. E 级：ALU
4. M 级：DM
5. W 级：无

连线参考教程和 P4。需要注意的有两点：
1. 新元件 CMP 用于 b 类指令
2. NPC 位于 D 级，他的输入中既需要 `D_pc` （b 类，j 类），又需要 `F_pc` （PC+4）。

### 控制器架构

控制器我分为三部分。第一部分分割指令（取出 rs，imm 等），第二部分解析指令（``wire add = (opcode == `OP_add) && (func == `FU_add)``），第三部分分类指令（`load`之类），第四部分建模控制信号。

采用统一控制器的好处是，在数据通路、转发、阻塞中你都可以复用这些代码。

## 转发

只有 RS 和 RT 会被转发。有四个位点是转发的接受端：
1. NPC 的 RS 输入端
2. CMP 的两个输入端
3. ALU 的输入端
4. DM 的输入端

这里推荐用一个 `Forward Unit` 来控制所有的转发。FU 输入各级的指令，输出某一级的数据能否**被转发**，即能否成为供给端。如 `forwardE` 表示 E 级寄存器的数据能被转发。能被转发的信号要求其值已经被算出来了，如 M 级可以转发 `jal`, `jalr`, 所有 r 型指令，所有 I 型指令。

因此我们有 `assign forwardM = M_j_l | M_calc_r | M_calc_i;`。

同理可以构造 E、W 级的转发信号。可以的话最好实先画一个图。

| 转发接受    |
|-------------|
| NPC         |
| D\_CMP\_A/B |
| ALU\_A/B    |
| DM\_in      |

| 转发输出       | （就近优先）    |
|----------------|-----------------|
| E\_reg         | j\_l            |
| M\_reg         | calc\_r/calc\_i |
| W\_reg         | load            |
| 寄存器内部转发 |                 |


然后是接受端选择数据，选择的顺序按照**就近原则**，优先选择下一级的数据，不行就下两级，如果都不行就采用本级寄存器的数据。接受端可以接受数据的条件为：
1. 供给端的寄存器地址与当前的相同
2. 地址不为 0
3. 供给端可以转发
4. 供给端的指令会写数据。

即：

```verilog
wire [31:0] FWD_E_RS =  (E_rs_addr == M_RFDst && forwardM) ? M_RFWD :
                        // ...
                        E_rs;
```

需要注意的有以下几点：
1. 本级的寄存器接受了转发后，一律使用转发后的值。我们可以把使用原值也看成一种转发，即我们必须使用最新的值，包括给下一级寄存器传递信息时也要用转发后的数据。

    如 `FWD_E_RS` 是转发后的值，那么在 `M_reg` 的 `rs_in` 信号就要用 `FWD_E_RS` 而不是 `E_rs`。

2. 寄存器内部转发

    其实就是 D 级接受 W 级的转发电路放在了寄存器内部

    ```verilog
    assign RD1 = (A3 == A1 && A3 && WE) ? WD : grf[A1]; // 内部转发
    ```

3. 为什么转发不需要判断 `M_RFWE`？因为在 `M_RFDst` 中我们令不写寄存器的部件的写入地址为 `$0`，所以不会对结果造成影响。

## 阻塞

建议通读教程，看一遍高老板的 PPT，尤其要搞清楚 Tuse 和 Tnew 两个东西。

- Tuse：指令进入 D 级后，其后的某个功能部件再经过多少时钟周期就必须要使用寄存器值。对于有两个操作数的指令，其每个操作数的 Tuse 值可能不等（如 store 型指令 rs、rt 的 Tuse 分别为 1 和 2）。
- Tnew：位于 E 级及其后各级的指令，再经过多少周期就能够产生要写入寄存器的结果。在我们目前的 CPU 中，W 级的指令 Tnew 恒为 0；对于同一条指令，Tnew@M = max(Tnew@E - 1, 0)。

然后直接遵循 `Tuse < Tnew` 则阻塞的规则就可以了。建议先画一个表格分类 Tuse 和 Tnew。可以按照高老板的 PPT，用“产生输出的部件”来分类 Tnew。如 ALU 产生输出的有 R 型、I 型、sw 的地址，把他们归为一类。

阻塞时只需要判断 RS 和 RT。

| Tuse               |   |             |   |
|--------------------|---|-------------|---|
| calc\_r(rs)\shiftS | 1 | calc\_r(rt) | 1 |
| calc\_i(rs)        | 1 | shiftS(rt)  | 1 |
| load(rs)           | 1 | store(rt)   | 2 |
| store(rs)          | 1 | branch(rt)  | 0 |
| branch(rs)         | 0 |             |   |
| jr/jalr(rs)        | 0 |             |   |

判断的时候要注意条件：
1. `Tuse < Tnew`
2. 写入地址不为 0
3. 写入地址和后面级写入地址相同
4. 后面级可写寄存器

```verilog
wire [2:0] TuseRS =     (D_branch | D_j_r) ? 3'd0 :
                        // ...
                        3'd0;

// ...

wire [2:0] TnewE =  E_calc_r | E_calc_i ? 3'd1 :
                    // ...
                    3'd0;

// ...

wire stall_rs_e = (TuseRS < TnewE) && (D_rs_addr && D_rs_addr == E_RFDst) && E_RFWr;
// ...
wire stall_rs = stall_rs_e | stall_rs_m;

// ...

assign stall = stall_rs | stall_rt;
```
