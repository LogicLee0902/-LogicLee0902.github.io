---
layout:     post
title:      "「Head First Java」04 Inheritance and polymorphism"
subtitle:   继承与多态
date:       2022-02-26
author:     Leo

header-img: ""
catalog: true
tags: ["Java@Languages@Tags", "Head First Java@Books@Series"]
lang: zh
header-style: text
katex: true
---

# 继承

关键字`extends`

简单来说就是找相同的部分，认它当父亲，从而关注于新增的部分。

选择父类时也要尽可能抽象，子类可以使用父类的方法，可以加入自己的方法，也可以覆盖掉父类的方法（高级一点，or专业一点就是重写）

多个类之间可能即有共性的行为，也有共性的数据属性，此时使用类建立抽象层次更加合适

**注意一点**：子类可以调用父亲的方法，父亲不能调用子类的方法。

同样继承时，继承public而**不能继承**private

如果子类想在原有方法上添加可以使用`super.function()`	先行调用父亲的内容

如果不想让某个东西被继承，可以使用final，它表示是继承树的末端，不能被继承，也不可被覆盖

（还有别的方法，如可以控制存储，将类标记为非公有，这样就只会被同一个包的类当作父类；也可让类只拥有private的构造程序(Constructer)。）



## 重写(Override )

-----

和父亲不同的方法，利用重写了更新

一般会用`@Override`进行标识，Java会从层次树的最下方找方法（最最儿子的），一般是引用变量的实例化方法，因此找到儿子的方法之后就不会向上找父亲的，可以保证方法调用的准确性。

**注意**，可以通过重写覆盖方法，但实例变量不会被覆盖。

### 规则

---

* 重写时应该保证参数与返回值和之前的一样，**子类要保证能够执行父类的一切**

* 不能降低方法的存储权限，只能相同或更为开方，即不能覆盖一个方法使其变为私有

## 重载(Overload)

---

**两个方法的名称相同，但参数不同**，可以理解就是个相同名字的不同方法。

同时也要注意，重载的返回类型可以不同，但不能只改变返回类型，参数也应该改变，但是返回类型可以相同。即，重载的核心在于参数的不同，返回类型可以自由定义。

重载时也可以自由的定义方法的存取权限

# 多态

---
> *当定义出一组类的父型时，可以用子型的任何类来填补任何需要或期待父型的位置*
>
> *---Head First Java*

引用与对象可以是不同类型，一般来说是定义引用类型为实际对象的父类，换句话说，任何extends过声明引用变量类型的对象都可以被赋值给这个引用变量。

一般使用的是数据结构（数组这种），可以使得每个成员在一个抽象父亲的前提下，又是独特的个体，面向对象的优越性啊

```java
Animal[] animals = new Animal[5];
animals[0] = new Dog();
animals[1] = new Cat();
animals[2] = new Wolf();
animals[3] = new Hippo();
animals[4] = new Lion();
```

这样Java也能确保调用相同的方法时，调用的是所实例化对象的房。

参数与返回类型也都可以是多态，**重写不属于多态**