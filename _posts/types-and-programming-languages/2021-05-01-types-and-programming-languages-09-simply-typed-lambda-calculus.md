---
layout: "post"
title: "「TAPL」 09 Simply Typed Lambda-Calculus"
subtitle: "简单类型 Lambda 演算"
author: "roife"
date: 2021-05-01

tags: ["Types and Programming Languages@Books@Series", "PKU - 编程语言的设计原理@Courses@Series", "程序语言理论@Tags@Tags", "类型系统@Tags@Tags"]
lang: zh
catalog: true
header-image: ""
header-style: text
katex: true
---

本章讨论包含 Bool 和 λ 演算的类型系统，在保证类型安全的同时，使其可以描述我们写的大多数程序。

由于纯 λ 演算是图灵完备的，所以无法准确地确定一个程序的准确类型。例如下面的程序只有在运行时才能知道具体的返回类型：

$$
\operatorname{\mathtt{if}} \text{<long and tricky computation>} \operatorname{\mathtt{then}} \operatorname{\mathtt{true}} \operatorname{\mathtt{else}} (\lambda x. x)
$$

# Function Types

函数类型：

$$
\lambda x.t : \rightarrow
$$

为了让类型描述得更准确，需要加入参数类型和返回值类型：

$$
T_1 \rightarrow T_2
$$

**Type constructor** $\rightarrow$ 是右结合的，所以 $T\_1 \rightarrow T\_2 \rightarrow T\_3 = T\_1 \rightarrow (T\_2 \rightarrow T\_3)$。

注意 $(\operatorname{\mathtt{Bool}} \rightarrow \operatorname{\mathtt{Bool}}) \rightarrow \operatorname{\mathtt{Bool}} \rightarrow \operatorname{\mathtt{Bool}}$ 表示传入一个函数；而 $\operatorname{\mathtt{Bool}} \rightarrow \operatorname{\mathtt{Bool}} \rightarrow \operatorname{\mathtt{Bool}} \rightarrow \operatorname{\mathtt{Bool}}$ 只是传入一个 `Bool`。

**Definition** The set of simple types over the type Bool is generated by the following grammar:

$$
\begin{aligned}
T \Coloneqq & & \text{types} \\
    & \mathtt{Bool} & \text{type of booleans} \\
    & T \rightarrow T & \text{type of functions}
\end{aligned}
$$

# The Typing Relation

## Abstraction

### Arguments

有两种方式可以给出一个 abstraction 的参数的类型（这本书主要使用 explicitly typed）：
- 显式写出类型 $\lambda x : T\_1 . t\_2$，这可以帮助类型检查器进行检查，称为 explicitly typed
- 让类型检查器自动推导（这个过程称为 infer 或 reconstruct），称为 implicitly typed（在 λ 演算中，也会称之为 type-assignment systems）

### Body

知道了参数类型后，其函数返回值类型即为 body 的类型。

$$
\dfrac {
    x : T_1 \vdash t_2 : T_2
} {
    \vdash \lambda x : T_1 . t_2 : T_1 \rightarrow T_2
} \tag{T-Abs}
$$

## Typing context

当对象嵌套在一个 abstraction 里面的时候，需要考虑其所在的上下文，表示为 $\Gamma \vdash t : T$。其中 $\Gamma$ 称为 typing context 或者 type environment（A typing context $\Gamma$ is a sequence of variables and their types）。如果没有上下文环境，则可以记作 $\emptyset$，或者不在类型推导中写出，即 $\vdash t : T$。

用逗号可以向环境中添加规则，例如 $\Gamma, x : T\_1 \vdash t\_2 : T\_2$。添加规则时可能会遇到变量重名的问题，此时可以做 alpha-conversion。

$\Gamma$ 可以看作一个将变量映射到类型的有穷函数，其定义域为被绑定的变量集合，记作 $dom(\Gamma)$。

$$
\dfrac {
    \Gamma, x : T_1 \vdash t_2 : T_2
} {
    \Gamma \vdash \lambda x : T_1 . t_2 : T_1 \rightarrow T_2
} \tag{T-Abs}
$$

通过 $\Gamma$ 也可以得到变量的类型：

$$
\dfrac {
    x : T \in \Gamma
} {
    \Gamma \vdash x : T
} \tag{T-Var}
$$

## Application

$$
\dfrac {
    \Gamma \vdash t_1 : T_{11} \rightarrow T_{12} \qquad \Gamma \vdash t_2 : T_{11}
} {
    \Gamma \vdash t_1\ t_2 : T_{12}
} \tag{T-App}
$$

## If

$$
\dfrac {
    \Gamma \vdash t_1 : \operatorname{\mathtt{Bool}} \qquad \Gamma \vdash t_2 : T \qquad \Gamma \vdash t_3 : T
} {
    \Gamma \vdash \operatorname{\mathtt{if}} t_1 \operatorname{\mathtt{then}} t_2 \operatorname{\mathtt{else}} t_3 : T
} \tag{T-If}
$$

## $\lambda_\rightarrow$

通常用 $\lambda\_\rightarrow$ 来表示 STLC。

如果 STLC 中没有 base types（如 `Bool`），那么它是 degenerate，即其中没有 well-typed terms。因为没有 base types 那么就相当于归纳法中缺少了基础情况，不能构建其他类型。

# Properties of Typing

